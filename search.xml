<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++的进阶语法</title>
    <url>/2023/11/06/C++%E7%9A%84%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95(%E4%BB%85%E8%AF%AD%E6%B3%95%E5%B1%82%E9%9D%A2)/</url>
    <content><![CDATA[<p>最近复习一下语法，结合了以下三本工具书，记录一下有收获的点：</p>
<ul>
<li>《C++ Primer》</li>
<li>《Effective C++》</li>
<li>《More Effective C++》</li>
</ul>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>个人认为，重载是C++区别于C的三大特性（封装，继承，多态）中属于封装的重要特性之一，注意，重载（Overloading）是一种封装（Encapsulation）的概念而非多态，它允许在同一个作用域内使用相同的名称，但是参数列表不同的函数或方法。</p>
<blockquote>
<p>重载 是一种封装的概念，它提供了一种通过相同的名称执行不同操作的机制，提高了函数或方法的可用性和易用性。<br>多态 是面向对象编程的一个特性，它允许不同的对象对相同的消息做出不同的响应，提高了代码的灵活性和可扩展性。</p>
</blockquote>
<p>下面介绍一些重载的高阶用法：</p>
<span id="more"></span>

<h3 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h3><p>内容略</p>
<h2 id="模板-Template"><a href="#模板-Template" class="headerlink" title="模板(Template)"></a>模板(Template)</h2><h3 id="模板实参推断过程中的类型转换"><a href="#模板实参推断过程中的类型转换" class="headerlink" title="模板实参推断过程中的类型转换"></a>模板实参推断过程中的类型转换</h3><p>这也是指针和引用的重大区别之一！！！就是在函数模板实参推断过程中是否允许类型转换！！！</p>
<h3 id="模板的显式具体化"><a href="#模板的显式具体化" class="headerlink" title="模板的显式具体化"></a>模板的显式具体化</h3>]]></content>
      <categories>
        <category>2023-11</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++const与static关键字</title>
    <url>/2023/11/14/C-C-const%E4%B8%8Estatic%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>这一节主要给大家介绍C语言中经常令人迷惑的两个关键字const和static，考虑到大家的基础，我只在课堂上讲授最初级的内容，但是初级不等于不重要，也决不等于简单，相反，学好初级的内容在编程当中具有十分重要的意义，是各位今后理解更高级别代码的基石，希望大家对下面的内容做到精准掌握！后续，我会根据情况逐渐对这篇博客进行完善，补充一些更高级的用法和更深层次的知识，下面，让我们从内存开始——</p>
<span id="more"></span>

<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows是闭源的，有版权保护，资料较少，不好深入研究每一个细节，至今仍有一些内部原理不被大家知晓。下图是一个典型的 Windows 32位程序的内存分布：<br><img src="/images/32.jpg" alt="Windows内存分布"></p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="是这样吗？"><a href="#是这样吗？" class="headerlink" title="是这样吗？"></a>是这样吗？</h3><p>Me：<br>但是在我int &amp;a &#x3D; f（int b）的例子中，f函数返回的也是一个临时的整数值啊，为什么绑定到临时的整形上就不会错，绑定到临时的pair上就会错呢？<br>ChatGPT：<br>好问题！这涉及到 C++ 中的两种不同的语法和行为。</p>
<p>在 C++ 中，绑定到临时值的非 const 引用是允许的，但有一个重要的区别：</p>
<p>对于基本数据类型（如整数），非 const 引用可以绑定到临时值，因为整数是可修改的。</p>
<p>对于复杂的用户定义类型（如 pair&lt;int, int&gt;），非 const 引用不能直接绑定到临时值。这是因为，与整数不同，pair&lt;int, int&gt; 是一个复杂的对象，C++ 规定不能通过非 const 引用修改临时对象，以防止悬垂引用问题。</p>
<p>这就是为什么在你的原始代码中，当你尝试用非 const 引用绑定到 pair&lt;int, int&gt; 类型的临时值时，编译器报错的原因。而在 int &amp;a &#x3D; f(int b) 这种情况下，int 是一个基本数据类型，可以通过非 const 引用绑定到临时值。</p>
<h2 id="如果你想要修改-pair-类型的临时值，可以使用-const-引用：这样就能够避免编译错误。希望这能帮助解释这个问题。"><a href="#如果你想要修改-pair-类型的临时值，可以使用-const-引用：这样就能够避免编译错误。希望这能帮助解释这个问题。" class="headerlink" title="如果你想要修改 pair&lt;int, int&gt; 类型的临时值，可以使用 const 引用：这样就能够避免编译错误。希望这能帮助解释这个问题。"></a>如果你想要修改 pair&lt;int, int&gt; 类型的临时值，可以使用 const 引用：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp</span><br><span class="line">const auto &amp;[l1, r1] = f(s, i, i);</span><br><span class="line">const auto &amp;[l2, r2] = f(s, i, i + 1);</span><br></pre></td></tr></table></figure><br>这样就能够避免编译错误。希望这能帮助解释这个问题。</h2><p>这是真的吗？？？</p>
]]></content>
      <categories>
        <category>2023-11</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/01/hello-world/</url>
    <content><![CDATA[<p>兄弟们，你们的到来使我感动不已，我只能说：Welcome to 我的新家，欢迎你们常来做客！</p>
<h1 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h1><p>本篇是建站以来第一篇文章，将来等文章多了他就刷到底下去了，但是一篇文章的沉底并不代表着他的消失和埋没，反而象征着这里古老的地基；有时候，网站和团队多么像啊，一篇篇文章就像团队的一个个人一样。希望将来再看到这篇文章的时候，还记得自己当时为什么出发&gt;~&lt;</p>
<p>————yours ymlf</p>
]]></content>
      <categories>
        <category>2023-11</category>
      </categories>
  </entry>
  <entry>
    <title>我和《长汀往事》</title>
    <url>/2023/11/06/%E6%88%91%E5%92%8C%E3%80%8A%E9%95%BF%E6%B1%80%E5%BE%80%E4%BA%8B%E3%80%8B/</url>
    <content><![CDATA[<h2 id="长汀往事"><a href="#长汀往事" class="headerlink" title="长汀往事"></a>长汀往事</h2><p>关于长汀的心路历程，已经在叶子老师的采访中讲述完毕了，这里就略过了，等推送出了我把链接甩上来</p>
]]></content>
      <categories>
        <category>2023-11</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>基础代码面</title>
    <url>/2023/11/13/%E6%8A%80%E6%9C%AF%E9%9D%A2/</url>
    <content><![CDATA[<h4 id="实现可变长数组"><a href="#实现可变长数组" class="headerlink" title="实现可变长数组"></a>实现可变长数组</h4><p>这种问题要记住实现两版，一定不要忘了写const对象的版本</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Array&#123;</span><br><span class="line">public:</span><br><span class="line">    Array(int length = 0);</span><br><span class="line">    ~Array();</span><br><span class="line">public:</span><br><span class="line">    int &amp; operator[](int i);</span><br><span class="line">    const int &amp; operator[](int i) const;</span><br><span class="line">public:</span><br><span class="line">    int length() const &#123; return m_length; &#125;</span><br><span class="line">    void display() const;</span><br><span class="line">private:</span><br><span class="line">    int m_length;  //数组长度</span><br><span class="line">    int *m_p;  //指向数组内存的指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(int length): m_length(length)&#123;</span><br><span class="line">    if(length == 0)&#123;</span><br><span class="line">        m_p = NULL;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        m_p = new int[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array()&#123;</span><br><span class="line">    delete[] m_p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int&amp; Array::operator[](int i)&#123;</span><br><span class="line">    return m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const int &amp; Array::operator[](int i) const&#123;</span><br><span class="line">    return m_p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Array::display() const&#123;</span><br><span class="line">    for(int i = 0; i &lt; m_length; i++)&#123;</span><br><span class="line">        if(i == m_length - 1)&#123;</span><br><span class="line">            cout&lt;&lt;m_p[i]&lt;&lt;endl;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            cout&lt;&lt;m_p[i]&lt;&lt;&quot;, &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    Array A(n);</span><br><span class="line">    for(int i = 0, len = A.length(); i &lt; len; i++)&#123;</span><br><span class="line">        A[i] = i * 5;</span><br><span class="line">    &#125;</span><br><span class="line">    A.display();</span><br><span class="line">   </span><br><span class="line">    const Array B(n);</span><br><span class="line">    cout&lt;&lt;B[n-1]&lt;&lt;endl;  //访问最后一个元素</span><br><span class="line">   </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>这周日争取学一下github新出的markdown神器，顺便这两篇文章中的代码高亮方法：<a href="https://www.yuque.com/yumulinfengfirepigreturn/yrgoyf/dtno1rcrfldrpbqe#YgwOv">语雀链接（仅我可见）</a></p>
]]></content>
      <categories>
        <category>2023-11</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C &amp;&amp; C++ 易混淆问题</title>
    <url>/2023/11/05/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>bug太多了，哭了啊，今天又修了一天，可算把搜索功能整好了，后续打算开发一个评论功能，看有没有精力吧zzz</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在C++中，<code>char str = &quot;afefa&quot;;</code> 是一个不合法的语法。如果你想声明一个字符串，正确的方式是使用字符数组（C风格字符串）或者C++的<code>std::string</code>类。下面是两种合法的方式：</p>
<span id="more"></span>

<ol>
<li><strong>使用字符数组（C风格字符串）：</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;afefa&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，编译器会在内存中分配足够的空间来存储字符串及其结尾的空字符（’\0’）。<code>str</code> 数组的大小将是字符串长度加上一个额外的字节来存储空字符。在这个例子中，<code>str</code> 的大小将是 6 字节（5 个字符 + 1 个空字符）。</p>
<p>内存结构示意图（每个方框代表一个字节）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---+---+---+---+---+---+</span><br><span class="line">| a | f | e | f | a | \0|</span><br><span class="line">+---+---+---+---+---+---+</span><br></pre></td></tr></table></figure>

<p>值得注意的是，这种写法目前已经被GCCban了，会报warning，我个人建议写成const char str[] &#x3D; “…”，这样更符合常量字符串的定义。</p>
<ol start="2">
<li><strong>使用<code>std::string</code>类：</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::string str = <span class="string">&quot;afefa&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>std::string</code>类时，字符串的长度和内存管理由<code>std::string</code>类自动处理，你无需担心内存结构。<code>std::string</code>类会在需要时动态分配内存以容纳字符串。</p>
]]></content>
      <categories>
        <category>2023-11</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题：找出最长回文子串</title>
    <url>/2023/12/04/%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>今天刷到一道很经典的算法题：找出字符串的最长回文子串，常见的思路是中心扩散，算法是dp，但是题解中有两个十分优秀的算法，特作记录</p>
<span id="more"></span>

<h3 id="算法一：暴力-O-n-2-TLE"><a href="#算法一：暴力-O-n-2-TLE" class="headerlink" title="算法一：暴力(O(n^2))(TLE)"></a>算法一：暴力(O(n^2))(TLE)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        string ans = &quot;&quot;;</span><br><span class="line">        int n_max = 0;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            int n = 1;</span><br><span class="line">            string res(1, s[i]);</span><br><span class="line">            for(int j = 1; ; ++j)&#123;</span><br><span class="line">                if(i - j &lt; 0 || i + j &gt;= s.size() || s[i - j] != s[i + j])&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    n += 2;</span><br><span class="line">                    res = s[i - j] + res + s[i + j];</span><br><span class="line">                    // cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(n &gt; n_max)&#123;</span><br><span class="line">                n_max = n;</span><br><span class="line">                ans = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            int n = 1;</span><br><span class="line">            string res = &quot;&quot;;</span><br><span class="line">            for(int j = 0; ; j ++)&#123;</span><br><span class="line">                if(i - j &lt; 0 || i + j + 1 &gt;= s.size() || s[i - j] != s[i + j + 1])&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    n += 2;</span><br><span class="line">                    res = s[i - j] + res + s[i + 1 + j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(n &gt; n_max)&#123;</span><br><span class="line">                n_max = n;</span><br><span class="line">                ans = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="算法二：DP-O-n-2"><a href="#算法二：DP-O-n-2" class="headerlink" title="算法二：DP(O(n^2))"></a>算法二：DP(O(n^2))</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if (n &lt; 2) &#123;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int maxLen = 1;</span><br><span class="line">        int begin = 0;</span><br><span class="line">        // dp[i][j] 表示 s[i..j] 是否是回文串</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n));</span><br><span class="line">        // 初始化：所有长度为 1 的子串都是回文串</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 递推开始</span><br><span class="line">        // 先枚举子串长度</span><br><span class="line">        for (int L = 2; L &lt;= n; L++) &#123;</span><br><span class="line">            // 枚举左边界，左边界的上限设置可以宽松一些</span><br><span class="line">            for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span><br><span class="line">                int j = L + i - 1;</span><br><span class="line">                // 如果右边界越界，就可以退出当前循环</span><br><span class="line">                if (j &gt;= n) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (s[i] != s[j]) &#123;</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (j - i &lt; 3) &#123;</span><br><span class="line">                        dp[i][j] = true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        dp[i][j] = dp[i + 1][j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span><br><span class="line">                if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + 1;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substr(begin, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 真-中心扩散</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    pair &lt;int, int&gt; f(const string&amp; s, int l, int r)&#123;</span><br><span class="line">        while(l &gt;= 0 &amp;&amp; r &lt; s.size() &amp;&amp; s[l] == s[r])&#123;</span><br><span class="line">            l --;</span><br><span class="line">            r ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;l + 1, r - 1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    string longestPalindrome(string s) &#123;</span><br><span class="line">        int n = s.size();</span><br><span class="line">        if(n &lt; 1)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        int st = 0, ed = 0;</span><br><span class="line">        for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            const auto &amp;[l1, r1] = f(s, i, i);</span><br><span class="line">            const auto &amp;[l2, r2] = f(s, i, i + 1);</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; l1 &lt;&lt; &#x27; &#x27; &lt;&lt; r1 &lt;&lt; &#x27; &#x27; &lt;&lt; l2 &lt;&lt; &#x27; &#x27; &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line">            // auto [l1, r1] = f(s, i, i);</span><br><span class="line">            // auto [l2, r2] = f(s, i, i + 1);</span><br><span class="line">            if((r1 - l1 + 1) &gt; (ed - st + 1))&#123;</span><br><span class="line">                st = l1;</span><br><span class="line">                ed = r1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(r2 - l2 + 1 &gt; ed - st + 1)&#123;</span><br><span class="line">                st = l2;</span><br><span class="line">                ed = r2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.substr(st, ed - st + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>算法一二的复杂度一样，但是算法二返回下标而算法一返回字串，这可能是二者时间的差距所在。</p>
<h3 id="算法三：倒序求交集"><a href="#算法三：倒序求交集" class="headerlink" title="算法三：倒序求交集"></a>算法三：倒序求交集</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestPalindrome(String s) &#123;</span><br><span class="line"></span><br><span class="line">        int length = s.length();</span><br><span class="line">        String maxStr=&quot;&quot;;</span><br><span class="line">        String reverse=new StringBuffer(s).reverse().toString();</span><br><span class="line"></span><br><span class="line">        int x=0;</span><br><span class="line">        int y=1;</span><br><span class="line">        while (x&lt;length&amp;&amp;y&lt;=length)&#123;</span><br><span class="line">            String substring = s.substring(x, y);</span><br><span class="line">            if (reverse.contains(substring))&#123;</span><br><span class="line">                if(substring.equals(new StringBuffer(substring).reverse().toString()))</span><br><span class="line">                if (substring.length()&gt;maxStr.length())&#123;</span><br><span class="line">                    maxStr=substring;</span><br><span class="line">                &#125;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                x++;</span><br><span class="line">                y=x+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return maxStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法四：Manacher算法-O-n"><a href="#算法四：Manacher算法-O-n" class="headerlink" title="算法四：Manacher算法(O(n))"></a>算法四：Manacher算法(O(n))</h3><p>详见：<a href="leetcode%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3">https://leetcode.cn/problems/longest-palindromic-substring/solutions/255195/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/</a></p>
]]></content>
      <categories>
        <category>2023-12</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
